# 简介
写这个 RPC 框架的目的，大概就是一个通过造轮子的方式来检验学习成果，并且学习新知识的过程  
我会尽量把注释写简单清楚，方便理解，实现一个基本功能的 RPC 框架，慢慢完善

<br>

# 工具
+ IntelliJ IDEA
+ JDK 1.8.0_281
+ GitHub Desktop

<br>

# 关于RPC
首先了解什么叫RPC，为什么要RPC，RPC是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据

<br>

# 项目进度

## Version1：  
### 通信模式

<br>

**前期使用的是传统的BIO通信模式**  
　　由一个独立线程负责监听客户端的连接，通过while(true)循环中,服务端调用accept()方法等待接收客户端的连接的方式监听请求。但此时不能再接收其他客户端的连接请求，只能等待当前客户端的操作完成。  
**所以我通过多线程来支持多个客户端的连接**  
>主要原因是socket.accept()、socket.read()、socket.write() 涉及的三个主要函数都是同步阻塞的

<br>
　　也就是说现在是服务端在接收到客户端的连接请求后，为每一个客户端创建一个新的线程，处理完成后通过输出流返回应答给客户端，线程销毁。这是典型的一请求一应答通信模型  
<br>
　　但是这个时候我们可以设想一下，如果线程不做别的操作就会造成不必要的开销，这时候我们使用线程池来改进它。

>线程是宝贵的资源，线程的创建和销毁成本很高，除此之外，线程的切换成本也是很高的，如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务  

　　当有新的客户端接入时，投递到后端的线程池中进行处理，JDK 的线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。  
>不过因为它的底层仍然是同步阻塞的BIO模型，因此无法从根本上解决问题，所以我们下一个版本需要引入Netty框架

<br>

### 服务端功能  

<br>
　　因为我们考虑到，所需要调用的方法名，以及客户端请求的host和port都是写死的，而且只能调用服务端Service唯一确定的方法，返回值也只支持一个对象，所以我们需要**对请求和返回值以及客户端进行抽象处理**。  

+ 这个版本我们定义了 Request 与 Response 格式，使用了动态代理进行不同服务方法的Request的封装，实现可以调用不同方法以及返回不同格式数据。  
+ 如果一个服务端要提供多个服务的接口，我们自然而然想到用一个Map来保存，如果来一个request，我们就可以通过获得request里的参数，来从map中取出对应的服务。



  
<br>

## Version2：  